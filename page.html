<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Maze3D</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="Maze3D" style="margin:8px;border:1px solid black" ></canvas>
  <button onclick="onclick2dm()">2dmap生成</button><button onclick="onclick3dm()">3dmap生成(未)</button>
  <script>
    // 3d表示参考 https://2dgames.jp/fake-3d-dungeon/  

    const [width,height] = [8,6]  //マスのサイズ
    const mSize = { x: width*2+1 , y: height*2+1 }; //壁も含めたサイズ
    const start = { 
      x: 0,
      y: 0
    };
    const goal ={ 
      x: width,
      y: height
    };
    const dirs =[[0,-1],[1,0],[0,1],[-1,0]];//

    const canvas = document.getElementById("Maze3D");
    const TileSize = 40;
    [canvas.width,canvas.height] = [width*TileSize,height*TileSize]
    const ctx = canvas.getContext("2d");
    
    let maze = Array.from({ length: mSize.y }, () => Array(mSize.x).fill(1));
    const getRandomInt = (max) => Math.floor(Math.random() * max);

    const mazeInit = () => {
      maze = Array.from({ length: mSize.y }, () => Array(mSize.x).fill(1));
      [start.x,start.y] = [getRandomInt(width),getRandomInt(height)];
      do{
        [goal.x,goal.y] = [getRandomInt(width),getRandomInt(height)];
      }while(goal.x == start.x && goal.y == start.y);      
    }
    function shuffle(array){
      for (let i = 0; i < array.length; i++) {
        const r = getRandomInt(i+1);
        [array[i], array[r]] = [array[r], array[i]];
      }
      return array;
    }
    function mazeGenerator(x,y){
      mazeInit();
      dig(x,y);
      randWallBraek(x,y);
      setplayer();
      window.addEventListener("load", main(), false);
    }
    function dig(x,y){
      maze[y][x] = 0;

      const dir = shuffle([...dirs]);
      for (const [dx, dy] of dir) {
        const nx = x + dx * 2;
        const mx = x + dx;
        const ny = y + dy * 2;
        const my = y + dy;

        if (0 < nx && nx < mSize.x - 1 && 0 < ny && ny < mSize.y - 1 && maze[ny][nx] === 1) {
          maze[my][mx] = 0;
          dig(nx, ny);
        }
      }
    }
    function randWallBraek(){
      const breakNum = Math.floor(width*height/5);
      const wallList = [];
      for (let y = 1; y < mSize.y - 1; y++) {
        for (let x = 1; x < mSize.x - 1; x++) {
          if (maze[y][x] === 1) {
            if (x % 2 === 1 || y % 2 === 1) {
              wallList.push({ x, y });
            }
          }
        }
      }
      shuffle(wallList);
      for (let i = 0; i < breakNum && i < wallList.length; i++) {
        const { x, y } = wallList[i];
        maze[y][x] = 0;
      }
    }
    function onclick2dm(){
      mazeGenerator(2*start.x+1,2*start.y+1);
      draw2dm();
    }
    function draw2dm(){
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const wallWidth = {
        x: canvas.width/(width*10),
        y: canvas.height/(height*10)
      }
      ctx.fillStyle = "black";
      for(let y = 0; y <= height; y++){
        for(let x = 0; x <= width; x++){
          let cx = x*2+1;
          let cy = y*2+1;
          if(cx < 2*width*1 && maze[cy-1][cx]==1){
            ctx.fillRect((x*10-1)*wallWidth.x, (y*10-1)*wallWidth.y, 12*wallWidth.x, 2*wallWidth.y);
          }
          if(cy < 2*height+1 && maze[cy][cx-1]==1){
            ctx.fillRect((x*10-1)*wallWidth.x, (y*10-1)*wallWidth.y, 2*wallWidth.x, 12*wallWidth.y);
          }
        }
      }
      ctx.fillStyle="#82d563";
      ctx.fillRect((start.x*10+2)*wallWidth.x, (start.y*10+2)*wallWidth.y , 6*wallWidth.x, 6*wallWidth.y);
      ctx.fillStyle="red";
      ctx.fillRect((goal.x*10+2)*wallWidth.x, (goal.y*10+2)*wallWidth.y , 6*wallWidth.x, 6*wallWidth.y);
      player.img.onload = () => {
        draw2dm();
        ctx.drawImage(player.img, (player.x)*TileSize +4, (player.y)*TileSize +4);
      }
    }

    function onclick3dm(){
      mazeGenerator(2*start.x+1,2*start.y+1);
      canvas.width = 720;
      canvas.height= canvas.width*3/4;
      draw3dm();
    }
    
    function isWall(x,y){
      return (x >= 0 && x < mSize.x && y >= 0 && y < mSize.y && maze[y][x]===1)
    }

    function playerView(){
      const {x,y,dir} = player;
      const [dirx,diry] = dirs[dir];
      const [dirvx,dirvy] = dirs[(dir+1)%4];
      
      const vw = [
        [
          isWall(x + dirx - 2*dirvx, y + diry - 2*dirvy),
          isWall(x + dirx          , y + diry          ),
          isWall(x + dirx + 2*dirvx, y + diry + 2*dirvy),
        ],
        [
          isWall(x + 3*dirx - 2*dirvx, y + 3*diry - 2*dirvy),
          isWall(x + 3*dirx          , y + 3*diry          ),
          isWall(x + 3*dirx + 2*dirvx, y + 3*diry + 2*dirvy),
        ],
        [
          isWall(x + 5*dirx - 2*dirvx, y + 5*diry - 2*dirvy),
          isWall(x + 5*dirx          , y + 5*diry          ),
          isWall(x + 5*dirx + 2*dirvx, y + 5*diry + 2*dirvy),
        ],
      ];
      const hw =[
        [
          isWall(x - dirvx, y - dirvy),
          isWall(x + dirvx, y + dirvy),
        ],
        [
          isWall(x + 2*dirx - dirvx, y + 2*diry - dirvy),
          isWall(x + 2*dirx + dirvx, y + 2*diry + dirvy),
        ],
        [
          isWall(x + 4*dirx - dirvx, y + 4*diry - dirvy),
          isWall(x + 4*dirx + dirvx, y + 4*diry + dirvy),
        ],
        [
          isWall(x + 6*dirx - dirvx, y + 6*diry - dirvy),
          isWall(x + 6*dirx + dirvx, y + 6*diry + dirvy),
        ],
      ]

      const view ={
        vw: vw,
        hw: hw
      }
      console.log(view)
      return view;
    }
    function draw3dm(){
      const cell = canvas.width/40;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      player.view = playerView();
      const [hw,vw] = [player.view.hw,player.view.hw];  

      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, 30*cell);
      ctx.fillStyle = "Gray"
      ctx.fillRect(0, 0, canvas.width, 9*cell);
      ctx.fillRect(0, 21*cell, canvas.width, 9*cell);

      ctx.fillStyle = "DarkGray";
      ctx.lineWidth = 1;

// w*h:40*30  vw3:12*12 3, vw2:16*16 4 ,vw1:24*24 6 

      if(hw[3][0]) ctx.fillRect(11*cell, 9*cell, 3*cell, 12*cell);
      if(hw[3][1]) ctx.fillRect(26*cell, 9*cell, 3*cell, 12*cell);

      if(vw[2][0]) ctx.fillRect(0, 9*cell, 14*cell, 12*cell);
      if(vw[2][1]) ctx.fillRect(11*cell, 9*cell, 18*cell, 12*cell);
      if(vw[2][2]) ctx.fillRect(26*cell, 9*cell, 14*cell, 12*cell);

      if(hw[2][0]){
        ctx.fillStyle = "blue"
        ctx.beginPath();
        ctx.moveTo(8*cell,7*cell);  ctx.lineTo(12*cell,7*cell);
        ctx.lineTo(14*cell,9*cell); ctx.lineTo(14*cell,21*cell);
        ctx.lineTo(12*cell,23*cell); ctx.lineTo(8*cell,23*cell);                  
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle ="darkGray"
      }
      if(hw[2][1]){
        ctx.fillStyle = "blue"
        ctx.beginPath();
        ctx.moveTo(32*cell,7*cell);  ctx.lineTo(28*cell,7*cell);
        ctx.lineTo(26*cell,9*cell); ctx.lineTo(26*cell,21*cell);
        ctx.lineTo(28*cell,23*cell); ctx.lineTo(32*cell,23*cell);                  
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle ="darkGray"
      }

      if(vw[1][0]) ctx.fillRect(0, 7*cell, 12*cell, 16*cell);
      if(vw[1][1]) ctx.fillRect(8*cell, 7*cell, 24*cell, 16*cell);
      if(vw[1][2]) ctx.fillRect(28*cell, 7*cell, 12*cell, 16*cell);

      if(hw[1][0]){
        // ctx.fillRect(11*cell, 9*cell, 3*cell, 8*cell);
      }
      if(hw[1][1]){
        // ctx.fillRect(26*cell, 9*cell, 3*cell, 8*cell);
      }

      if(vw[0][0]) ctx.fillRect(0, 3*cell, 8*cell, 24*cell);
      if(vw[0][1]) ctx.fillRect(2*cell, 3*cell, 36*cell, 24*cell);
      if(vw[0][2]) ctx.fillRect(32*cell, 3*cell, 8*cell, 24*cell);

      if(hw[0][0]){
        // ctx.fillRect(11*cell, 9*cell, 3*cell, 8*cell);
      }
      if(hw[0][1]){
        // ctx.fillRect(26*cell, 9*cell, 3*cell, 8*cell);
      }
    }

  //player関連
    const player = new Object();
    function setplayer(){
      player.img = new Image();
      player.x = start.x
      player.y = start.y;
      player.dir = 2; //n:0 e:1 s:2 w:3
      setPlayerImg()
    }
    function setPlayerImg(){
      switch (player.dir){
        case 0: player.img.src = "img/dot_up.png";    break;
        case 1: player.img.src = "img/dot_right.png"; break;
        case 2: player.img.src = "img/dot_down.png";  break;
        case 3: player.img.src = "img/dot_left.png";  break;
      }
    }
    function isGoal(){
      if(player.x == goal.x && player.y == goal.y) alert("goal!");
    };
    
  //key関連
    function keyEvent( event ) { 
      if (event.repeat) return;
      const key_code = event.keyCode;
      if( key_code === 37 ) player.dir = (player.dir+3) % 4;
      if( key_code === 38 ) {
        console.log(player);
        if(maze[2*player.y+1+dirs[player.dir][1]][2*player.x+1+dirs[player.dir][0]]==0){
          player.x += dirs[player.dir][0];
          player.y += dirs[player.dir][1];
        }
      }
      if( key_code === 39 ) player.dir = (player.dir+1) % 4;
      if( key_code === 40 ) player.dir = (player.dir+2) % 4;
      setPlayerImg();
      event.preventDefault();
      isGoal();
    }
    function main(){
      addEventListener("keydown", keyEvent, false);
    }

  </script>
</body>
</html>